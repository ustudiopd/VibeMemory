증상(“마크다운이 굵게만 나오고, 리스트/제목이 전혀 안 잡힘”)은 **렌더러 문제가 아니라 스트리밍 전달에서 줄바꿈(\n)이 유실**돼서 Markdown 문법이 “문장 중간의 `##`, `-` 문자”처럼 보이기 때문입니다.
코드를 보면 서버가 모델의 스트림을 **줄 단위로 쪼개서** 각 줄을 개별 SSE 이벤트로 보내고 있고, 클라이언트는 그 **줄들을 다시 붙일 때 줄바꿈을 복원하지 않습니다**. 그러면 제목·리스트는 “행의 시작”으로 인식되지 않아 모두 평문으로 붙어버리고, 첫머리의 굵은 강조가 길게 이어지면 “다 굵게” 보이는 효과가 납니다. 해당 로직은 `route.ts`의 `for await (const chunk of result.textStream)` 블록과, 클라이언트의 `onmessage(ev)`에서 단순 문자열 덧붙이기 부분에 그대로 확인됩니다.  

아래처럼 **서버·클라이언트 한 군데씩**만 손보면 바로 정상적인 Markdown 렌더링이 됩니다.

---

## 1) 서버(SSE) — **줄바꿈 보존해서 한 이벤트로 보내기** (권장)

지금은 한 `chunk`를 `split('\n')`해서 **여러 개의 `event: token`**으로 쏘고 있습니다. 이러면 줄 경계 정보가 사라집니다.
방법은 2가지가 있는데, 가장 단순한 **JSON.stringify 방식**을 추천합니다.

**`app/api/projects/[id]/chat/route.ts` (서버) — 패치**

```diff
- for await (const chunk of result.textStream) {
-   // (생략) 최초 sources 이벤트
-   const lines = chunk.split('\n');
-   for (let i = 0; i < lines.length; i++) {
-     const line = lines[i];
-     if (i < lines.length - 1 || line) {
-       const tokenEvent = `event: token\ndata: ${line}\n\n`;
-       controller.enqueue(encoder.encode(tokenEvent));
-     }
-   }
- }
+ for await (const chunk of result.textStream) {
+   // (생략) 최초 sources 이벤트
+   // 줄바꿈을 보존한 채로 "하나의 이벤트"에 실어 보낸다
+   const tokenEvent = `event: token\ndata: ${JSON.stringify(chunk)}\n\n`;
+   controller.enqueue(encoder.encode(tokenEvent));
+ }
```

> 배경: SSE 규격은 *한 이벤트 안에서* 여러 `data:` 라인을 보내면 자동으로 `\n`로 이어붙여 줍니다. 지금처럼 **이벤트를 여러 개로 쪼개면** 클라이언트가 줄바꿈을 직접 복원해야 해서 Markdown이 깨집니다. 현재 구현은 실제로 줄바꿈을 쪼개고 각 줄을 별도 이벤트로 보내고 있습니다. 

대안) 규격적으로 보내고 싶다면 다음처럼 **여러 `data:` 라인을 하나의 이벤트로** 전송해도 됩니다.

```ts
const tokenEvent = `event: token\n${
  chunk.split('\n').map(l => `data: ${l}`).join('\n')
}\n\n`;
```

---

## 2) 클라이언트 — **JSON 파싱 후 그대로 붙이기**

서버가 JSON으로 보냈으니, 클라이언트는 매번 안전하게 파싱해서 붙이면 됩니다.
현재도 “따옴표로 감싸져 있으면 파싱”을 시도하고 있는데, **무조건 파싱**으로 단순화하세요.

**`components/ChatInterface.tsx` — `onmessage` 부분 패치** 

```diff
onmessage(ev) {
-  if (ev.event === 'token') {
-    let tokenText = ev.data;
-    if (tokenText.startsWith('"') && tokenText.endsWith('"')) {
-      try { tokenText = JSON.parse(tokenText) } catch {}
-    }
-    setMessages(prev => prev.map(msg =>
-      msg.id === assistantMsgId ? { ...msg, content: msg.content + tokenText } : msg
-    ));
-  }
+  if (ev.event === 'token') {
+    let tokenText = ev.data;
+    try { tokenText = JSON.parse(ev.data); } catch { /* no-op */ }
+    setMessages(prev => prev.map(msg =>
+      msg.id === assistantMsgId
+        ? { ...msg, content: msg.content + tokenText } // tokenText 안의 \n 이 유지됨
+        : msg
+    ));
+  }
}
```

이렇게만 바꾸면 모델이 흘려보낸 `# 제목\n\n- 리스트`의 줄바꿈이 **그대로 보존**되어 ReactMarkdown이 정상적으로 제목/리스트를 렌더링합니다.

---

## 3) 렌더러/스타일 측 점검 체크리스트 (정상)

* **ReactMarkdown 설정은 적절**합니다. `remark-gfm`, `remark-breaks`, `rehype-sanitize`, `rehype-highlight`를 쓰고 있고, 요소별로 `p/li`에 `font-normal`을 줘서 기본이 굵게 되지 않습니다. 이쪽은 문제 원인이 아니었습니다. 
* 전역 CSS도 `.prose { font-weight: normal }`, `.prose p { font-weight: normal }`로 되어 있어 “전체가 굵게”되는 전역 규칙은 보이지 않습니다. 

> 다만 `ChatMarkdown.tsx`에서 **props 스프레드 오탈자**가 보입니다(`{.props}` → `{...props}`). 실제 저장본이 그렇다면 교정해야 빌드 에러/의도치 않은 렌더링이 방지됩니다. (예: `<a {...props} .../>`, `<code {...props}>`) 

---

## 4) 바로 확인하는 스모크 테스트

1. 챗봇에 아래 문장을 그대로 보내 보세요.

   ```
   # H1
   본문 한 줄

   ## H2
   - 항목1
   - 항목2

   **굵게**와 *기울임* 테스트
   ```

2. 기대 결과

   * `H1/H2`는 큰 제목/중간 제목으로, 리스트는 •로, 굵게/기울임은 정상 표시.
   * 코드블록은 회색 박스/하이라이트. (`rehype-highlight`) 
   * 문단은 일반 굵기(`font-weight: normal`). 

---

## 5) 참고: 지금 구조가 좋은 이유

* **마크다운 렌더러는 이미 충분**합니다(ReactMarkdown + GFM/Breaks/Highlight). 문제의 핵심은 **SSE 조립**이었고, 위 패치로 줄바꿈 보존만 해결하면 “챗GPT처럼” 자연스럽게 렌더링됩니다.
* 클라이언트는 이미 `fetch-event-source`를 쓰고 있어 POST로 SSE를 잘 받고 있고, 메시지 버블도 어시스턴트만 `ChatMarkdown`으로 그리도록 분리돼 있습니다. 

---

### 요약

* **원인**: 서버가 스트림을 줄 단위로 잘라 **개별 이벤트**로 보내고, 클라가 줄바꿈을 복원하지 않아 Markdown이 “평문”으로 붙음.  
* **해결**: `route.ts`에서 **JSON.stringify된 전체 chunk를 한 이벤트로** 보내고, 클라 `onmessage`에서 **항상 JSON 파싱 후 그대로 이어붙이기**.
* **렌더러/CSS**는 정상(기본이 `font-normal`). 필요 시 `...props` 오탈자만 정리.  

이대로 반영하면 리스트/제목/표/코드블록까지 깔끔하게 “챗GPT 스타일”로 뜹니다.
