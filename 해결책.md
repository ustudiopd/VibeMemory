확인했습니다. 올려주신 **아이디어 파일 업로드 400(Bad Request)** 리포트는 원인과 재현 경로가 잘 정리돼 있고, 실제로 **버킷의 `allowed_mime_types`와 업로드 시 전달되는 `Content-Type`이 불일치**할 때 Supabase Storage가 400을 반환하는 전형적인 케이스입니다. 특히 `.md` 파일이 브라우저/노드 환경에서 **`text/markdown`이 아닌 `text/plain`/`application/octet-stream`/빈 문자열**로 올라오는 상황이 흔해요. 리포트의 가설과 동일합니다. 

또, 과거 “스크린샷 버킷” 이슈처럼 **SQL로 만든 버킷 레코드를 Storage API가 인식하지 못해** 체크/생성이 꼬였던 전례도 있으므로(해결책: **반드시 Storage API로 존재 확인/생성**) 동일한 패턴으로 재검증이 필요합니다. 

아래 순서대로 적용하면 바로 해결됩니다.

---

## ✅ 결론(실행 순서)

1. **라우트에서 MIME 타입을 “확장자 기반”으로 정규화** → 업로드 옵션의 `contentType`을 **명시적으로 지정**
2. **Storage API로 버킷 생성/보증**(이미 존재 응답은 성공 처리)
3. (권장) **직접 업로드가 아닌 “서명 업로드 URL” 발급 → 클라이언트가 PUT**으로 올리는 방식으로 전환
4. (선택) 버킷 `allowed_mime_types`를 **`.md` 군에 맞춰 확장**(보수적으로)

---

## 1) 서버 라우트 패치 (최소 수정으로 즉시 해결)

> 파일: `app/api/projects/[id]/idea/files/route.ts` (Node 런타임 권장)
> 핵심: **확장자→MIME 정규화 + contentType 명시 + Storage API로 버킷 보증**

```ts
// app/api/projects/[id]/idea/files/route.ts
import { NextRequest, NextResponse } from 'next/server'
import path from 'node:path'
import { supabaseAdmin } from '@/lib/supabaseAdmin'
import { IDEA_FILES_BUCKET_NAME } from '@/lib/constants'

export const runtime = 'nodejs' // ← Edge보다 Node 권장 (Buffer 처리 안정)

function normalizeMime(filename: string, fallback?: string) {
  const ext = path.extname(filename).toLowerCase()
  if (ext === '.md') return 'text/markdown; charset=utf-8'
  if (ext === '.txt') return 'text/plain; charset=utf-8'
  return fallback || 'text/plain; charset=utf-8'
}

async function ensureIdeaBucket() {
  // Storage API로 보증 (SQL INSERT 금지)
  const { data: buckets, error: listErr } = await supabaseAdmin.storage.listBuckets()
  if (listErr) return false
  const exists = buckets?.some(b => b.name === IDEA_FILES_BUCKET_NAME)
  if (exists) return true

  const { error: createErr } = await supabaseAdmin.storage.createBucket(IDEA_FILES_BUCKET_NAME, {
    public: false,
    fileSizeLimit: 10 * 1024 * 1024,
    allowedMimeTypes: ['text/markdown', 'text/plain', 'text/x-markdown', 'application/x-markdown'],
  })
  // 이미 존재(409)도 성공 취급
  if (!createErr || createErr?.message?.includes('already exists') || (createErr as any)?.statusCode === 409) {
    return true
  }
  console.error('[STORAGE] createBucket failed:', createErr)
  return false
}

export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id
  const form = await req.formData()
  const file = form.get('file') as File | null
  if (!file) return NextResponse.json({ error: 'file not provided' }, { status: 400 })

  const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')
  const contentType = normalizeMime(safeName, file.type)

  // ① 버킷 보증
  const ok = await ensureIdeaBucket()
  if (!ok) return NextResponse.json({ error: 'bucket check failed' }, { status: 500 })

  // ② 업로드
  const fileId = crypto.randomUUID()
  const storagePath = `${projectId}/${fileId}/${safeName}`
  const buffer = Buffer.from(await file.arrayBuffer())

  const { error } = await supabaseAdmin.storage
    .from(IDEA_FILES_BUCKET_NAME)
    .upload(storagePath, buffer, {
      contentType,           // ← 반드시 명시
      upsert: true,
      cacheControl: '3600',
    })

  if (error) {
    // 원인 파악용 상세 로그
    console.error('[IDEA FILES] Upload failed:', {
      storagePath, contentType,
      statusCode: (error as any)?.statusCode, msg: error.message
    })
    return NextResponse.json({ error: 'upload failed', detail: error.message }, { status: 400 })
  }

  // (DB 메타 저장 로직 이어서…)
  return NextResponse.json({ ok: true, path: storagePath })
}
```

* `.md`면 **무조건 `text/markdown`** 으로 강제 지정 → 버킷 `allowed_mime_types`와 일치
* Storage 버킷 존재 보증은 **Storage API로만** 수행(Supabase 내부 캐시/메타와 일치 보장). 이는 과거 스크린샷 버킷 이슈의 재발을 막습니다. 
* 실패 시 **상세 로그**(`statusCode`, `message`)를 남겨 400의 정확한 원인을 즉시 확인할 수 있게 했습니다. 리포트의 로깅 강화 제안과 동일합니다. 

---

## 2) (권장) “서명 업로드 URL” 방식으로 전환

서버에서 파일 바디를 들고 있지 말고, **서버는 URL만 발급** → **클라이언트가 PUT** 으로 직접 올리면 Vercel 런타임/본문 제한과 MIME 불일치 리스크가 크게 줄어듭니다.

**서버**:

```ts
// POST /api/projects/:id/idea/files/upload-url
export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  const { filename } = await req.json()
  const safe = filename.replace(/[^a-zA-Z0-9._-]/g, '_')
  const contentType = normalizeMime(safe)

  await ensureIdeaBucket()
  const fileId = crypto.randomUUID()
  const path = `${params.id}/${fileId}/${safe}`

  const { data, error } = await supabaseAdmin.storage
    .from(IDEA_FILES_BUCKET_NAME)
    .createSignedUploadUrl(path, 60) // 60s 내 업로드
  if (error) return NextResponse.json({ error: error.message }, { status: 400 })

  return NextResponse.json({ uploadUrl: data.signedUrl, path, contentType })
}
```

**클라이언트**:

```ts
// 받은 uploadUrl에 곧바로 PUT
await fetch(uploadUrl, {
  method: 'PUT',
  headers: { 'Content-Type': contentType },
  body: file, // 브라우저 File 그대로
})
```

> 이 방식은 브라우저가 가진 합리적인 `Content-Type`을 그대로 전달하고, 서버는 메타만 관리합니다. (리포트의 “직접 업로드/본문 제한” 리스크 해소) 

---

## 3) 버킷 설정 가이드(보수적 확장)

운영환경에서 너무 느슨하게 열지 않되, `.md`에서 흔히 관측되는 타입은 받아 주는 것이 좋습니다.

* `allowed_mime_types`:
  `['text/markdown','text/plain','text/x-markdown','application/x-markdown']`
  (가능하면 `application/octet-stream`은 지양. 정말 필요하면 임시로만)

* 설정 변경은 **Dashboard** 또는 **Storage API `updateBucket`** 로 수행하세요.
  (SQL로 직접 업데이트하면 Storage 서비스의 내부 상태와 어긋날 수 있음 — 과거 사례 참조) 

---

## 4) 디버깅 체크리스트(빠른 검증)

1. **서버 로그**에서 실패 시 `statusCode`/`message` 찍히는지 확인 (400이면 거의 Content‑Type 미스매치) 
2. 브라우저 **Network** 탭에서 업로드 요청의 **Request Headers → Content‑Type** 확인
3. 버킷의 **allowed_mime_types** 배열이 위 권장안과 일치하는지 확인
4. **서명 업로드 URL**로 전환했으면 `PUT` 요청이 200이고, 같은 `path`로 **목록/다운로드**가 되는지

---

## 5) 왜 이게 맞나 (리포트와의 합치)

* 리포트의 1순위 가설(**MIME 타입 불일치**)을 코드에서 **정규화+명시 설정**으로 제거. 
* 버킷 생성/인식 문제는 **Storage API 사용**으로 일원화(과거 “버킷 존재하지만 API가 못 본다” 현상 차단). 
* 로깅·검증 절차는 리포트의 권고와 동일하게 반영했습니다. 

---

필요하시면, 현재 레포 구조에 맞춘 **완성 라우트 파일**(upload‑url 방식 포함)과 **클라이언트 훅/컴포넌트 예시**까지 바로 뽑아 드리겠습니다. 이 단계만 반영해도 `.md` 업로드 400은 사라질 가능성이 매우 높습니다.
